//
// Created by sebastian on 16.12.19.
//

#ifndef LLVM_TRANSFORMTREESEARCH_H
#define LLVM_TRANSFORMTREESEARCH_H

#include <iomanip>
#include "clang/Basic/Diagnostic.h"
#include "clang/Lex/HeaderSearchOptions.h"
#include "clang/Basic/CodeGenOptions.h"
#include "clang/Basic/TargetOptions.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/IR/LegacyPassManager.h"

#include "SimplexTuner.h"
#include "Optimizer.h"
#include "LoopTransformTree.h"
#include "Transformations.h"
#include "Debug.h"
#include "Tuners.h"

namespace clang {
namespace jit {

class TransformationTuner {
public:
  TransformationTuner(LoopTransformation& Transformation, unsigned MaxWithoutImprovement) : Transformation(Transformation), MaxWithoutImprovement(MaxWithoutImprovement) {
    HasTunableParams = Transformation.Space.getNumTunableDimensions() > 0;
    if (HasTunableParams) {
      if (Transformation.Space.getNumPossibleConfigs() <= 32) {
        TTuner = createTuner(TunerSearchAlgo::Grid, Transformation.Space);
      } else {
        TTuner = createTuner(loadSearchAlgoEnv(), Transformation.Space);
      }
    }
    JIT_INFO(outs() << "Tuning transformation of kind " << getTransformationName(Transformation.Kind) << "\n");
    JIT_INFO(outs() << "Search space: " << Transformation.Space << "\n");
    NeedsUpdate = true;
    BestIdx = -1;
    RequestsSinceImprovement = 0;
  }

  ConfigEval getNext() {

    RequestsSinceImprovement++;
    NeedsUpdate = true;
    ConfigEval Request;
    if (HasTunableParams) {
      Request = TTuner->generateNextConfig();
    }
    Configs.push_back(Request);
    return Request;
  }

  llvm::Optional<ConfigEval> getBest() {
    if (NeedsUpdate)
      updateBest();
    if (BestIdx >= 0)
      return Configs[BestIdx];
    return None;
  }

  bool isDone() {
    if (!HasTunableParams) {
      // Configs without parameters should be evaluated only once.
      return RequestsSinceImprovement > 0;
    }

    // If the search is finished, stop.
    if (TTuner->isDone())
      return true;

    if (NeedsUpdate)
      updateBest();

    // Otherwise, check if there have been improvements.
    return RequestsSinceImprovement >= MaxWithoutImprovement;
  }

  SearchSpace& getSearchSpace() {
    return Transformation.Space;
  }

  SmallVector<ConfigEval, 16> getAllConfigs() const {
    return Configs;
  }

  size_t getNumConfigs() const {
    return Configs.size();
  }

  /**
   * Returns the number of restarts that were needed to find the best configuration.
   * This may be smaller than the total number of restarts performed.
   * @return
   */
  unsigned getLastImprovementRestartIndex() const {
    return LastImprovementRestartIndex;
  }


private:
  void updateBest() {
    NeedsUpdate = false;
    int NewBestIdx = -1;
    TimingStats BestStats;

    for (auto I = 0; I < Configs.size(); I++) {
      auto& Cfg = Configs[I];
      if (Cfg.Stats->betterThan(BestStats)) {
        BestStats = *Cfg.Stats;
        NewBestIdx = I;
      }
    }
    if (NewBestIdx != BestIdx) {
      RequestsSinceImprovement = 0;
      if (TTuner)
        LastImprovementRestartIndex = TTuner->getNumRestarts();
    }
    BestIdx = NewBestIdx;
  }
private:
  bool HasTunableParams;
  LoopTransformation& Transformation;
  std::unique_ptr<Tuner> TTuner;
  // Stores all configuration generated by the search algo.
  SmallVector<ConfigEval, 16> Configs;
  int BestIdx;
  unsigned RequestsSinceImprovement;
  unsigned MaxWithoutImprovement;
  bool NeedsUpdate;

  unsigned LastImprovementRestartIndex{0};

};

struct TransformNode {

  using NodePtr = std::unique_ptr<TransformNode>;

  TransformNode(TimingStats Baseline, LoopTransformation Trans, LoopTransformTreePtr Tree, TransformNode* Parent = nullptr) : Baseline(Baseline), Transformation(Trans), LoopTree(std::move(Tree)), Parent(Parent) {
    assert(Baseline.valid());

    TTuner = std::make_unique<TransformationTuner>(Transformation, getMaxEvalLimit());
    UnexploredIdx = 0;
    ExpansionID = -1;
  }

  unsigned getMaxEvalLimit() {
    return 30;
    switch(getDepth()) {
      case 1:
      case 2:
        return 35;
      case 3:
        return 20;
      case 4:
        return 15;
      default:
        return 10;
    }
    llvm_unreachable("");
  }

  static float getMultiplier(const LoopTransformation& LT) {
    switch(LT.Kind) {
      case LoopTransformation::TILE:
        return 1.5;
      case LoopTransformation::INTERCHANGE:
        return 1.3;
      case LoopTransformation::UNROLL_AND_JAM:
        return 1.1;
      case LoopTransformation::UNROLL:
        return 1.0;
      case LoopTransformation::ARRAY_PACK:
        return 1.0;
    }
    llvm_unreachable("");
  }

  float getUnexploredMultiplier() {
    if (isFullyExplored()) {
      // All children expanded, nothing to do
      return 0;
    }
    // Available transformatios are sorted, so this should be the one with the highest multiplier.
    return getMultiplier(FeasibleTransformations[UnexploredIdx]);
  }

  bool isFullyExplored() {
    return UnexploredIdx >= FeasibleTransformations.size();
  }

  std::pair<float, TransformNode*> getMostPromisingNode(bool AllowRegression) {
    float ThisSpeedup = computeSpeedup();
    float ThisScore = computeScore(ThisSpeedup);
    std::pair<float, TransformNode*> MostPromising{ThisScore, this};
    for (auto& Child : Children) {
      if (!Child)
        continue;
      if (!AllowRegression && Child->computeSpeedup() < ThisSpeedup)
        continue;
      auto RecursiveBest = Child->getMostPromisingNode(AllowRegression);
      if (RecursiveBest.first > MostPromising.first)
        MostPromising = RecursiveBest;
    }
    return MostPromising;
  }

  static constexpr float BadScore = -1;

  float computeSpeedup() {
    auto Best = TTuner->getBest();
    if (Best) {
      auto Stats = Best.getValue().Stats;
      if (!Stats->valid())
        return BadScore;
      float Speedup = Baseline.Mean / Stats->Mean;
      return Speedup;
    }
    return BadScore;
  }

  float computeScore(float Speedup) {
    float Multiplier = getUnexploredMultiplier();
    if (Multiplier == 0)
      return 0;
    // Speedup is set to a negative value if no stats available
    if (Speedup < 0)
      return 0;
    return Speedup * Multiplier;
  }

  TransformNode& expand() {
    assert(UnexploredIdx < FeasibleTransformations.size() && "Node does not have any unexplored transformations");
    auto& Trans = FeasibleTransformations[UnexploredIdx];
    auto& Child = Children[UnexploredIdx];

    auto Best = TTuner->getBest();
    Child = std::make_unique<TransformNode>(Baseline, Trans, TransformedTree->clone(), this);
//    Child->FullConfig = Best->Cfg;
//    Child->FullConfig.addAll(FullConfig);
    UnexploredIdx++;
    return *Child;
  }

  LoopTransformTreePtr getTransformedTree(ParamConfig& Cfg, TransformationResult* Result = nullptr) {
    auto Tree = LoopTree->clone();
    auto Status = apply(Transformation, *Tree, Cfg);
    if (Result)
      *Result = Status;
    return Tree;
  }

  LoopTransformTreePtr applyBestConfig(TransformationResult* Result = nullptr) {
    auto Best = TTuner->getBest();
    if (!Best)
      return nullptr;
    return getTransformedTree(Best->Config, Result);
  }

  bool isEvaluated() {
    return TTuner->isDone();
  }

  void finalize() {
    assert(isEvaluated() && "Node must be evaluated before new transformations can be found");
    assert(FeasibleTransformations.empty() && !TransformedTree && "Can only be called once");
    TransformationResult Res = TransformationResult::FAILED;
    TransformedTree = applyBestConfig(&Res);
    assert(TransformedTree && Res != TransformationResult::FAILED);

    // Configurations such as UNROLL_AND_JAM(1, 1) are possible, which don't modidify the code at all.
    // If this is the case, stop exploring this branch because there is no difference to the parent node.
    // The root is node is excluded from this rule.
    if (Parent && Res == TransformationResult::SUCCESS_IDENTITY) {
      JIT_INFO(outs() << "Best found config " << TTuner->getBest()->Config << " is identity transformation - pruning this branch...\n");
      return;
    }

    FeasibleTransformations = findTransformations(TransformedTree.get());
    std::sort(FeasibleTransformations.begin(), FeasibleTransformations.end(), [](const LoopTransformation& T1, const LoopTransformation& T2) {
      return getMultiplier(T1) > getMultiplier(T2);
    });
    Children.resize(FeasibleTransformations.size());
    UnexploredIdx = 0;
  }

  unsigned getDepth() const {
    if (!Parent) {
      return 1;
    }
    return Parent->getDepth()+1;
  }


  llvm::raw_ostream& printPath(llvm::raw_ostream& OS = outs()) {
    if (!Parent) {
      OS << "Root";
      return OS;
    }
    Parent->printPath(OS);
    auto Best = TTuner->getBest();
    OS << " --> " << getTransformationName(Transformation.Kind);

    if (!Transformation.IntParams.empty()) {
      OS << "( ";
      for (unsigned I = 0; I < Transformation.IntParams.size(); I++) {
        OS << Transformation.IntParams[I] << " ";
        if (Transformation.FixedParams.size() > I)
          OS << "-> " << Transformation.FixedParams[I] << " ";
        if (I < Transformation.IntParams.size()-1)
          OS << ", ";
      }
      OS << ")";
    }

    if (Best && Best->Stats->valid()) {
      OS << Best->Config;
      OS << llvm::formatv(" [{0:f2}]", Baseline.Mean / Best->Stats->Mean);
    } else {
      OS << " [?]";
    }
    return OS;
  }


  TimingStats Baseline;
  LoopTransformTreePtr LoopTree;
  LoopTransformTreePtr TransformedTree;
  std::unique_ptr<TransformationTuner> TTuner;
  LoopTransformation Transformation;
  TransformNode* Parent;
  int ExpansionID;
//  KnobConfig FullConfig;
  SmallVector<LoopTransformation, 4> FeasibleTransformations;
  SmallVector<NodePtr, 4> Children;
  unsigned UnexploredIdx;
};

class TransformSearchTree {
public:
  TransformSearchTree(LoopTransformTreePtr OriginalTree, TimingStats BaselineStats)
    : Root(BaselineStats, LoopTransformation(), std::move(OriginalTree)) {
  }

  TransformNode& getMostPromisingNode(bool AllowRegression) {
    return *Root.getMostPromisingNode(AllowRegression).second;
  }

  bool isFullyExplored() {
    return Root.isFullyExplored();
  }

  TransformNode& getRoot() {
    return Root;
  }


private:
  TransformNode Root;
};


class TransformTreeOptimizer: public Optimizer {
public:

  static std::once_flag IsPollyInitialized;

  TransformTreeOptimizer(clang::DiagnosticsEngine &Diags,
                         const clang::HeaderSearchOptions &HeaderOpts,
                         const clang::CodeGenOptions &CGOpts,
                         const clang::TargetOptions &TOpts, const clang::LangOptions &LOpts,
                         llvm::TargetMachine &TM, bool AllowRegression)
      : Diags(Diags), HSOpts(HeaderOpts), CodeGenOpts(CGOpts),
        TargetOpts(TOpts), LangOpts(LOpts), TM(TM), AllowRegression(AllowRegression), ModToOptimize(nullptr), Done(false), ExpansionCounter(0) {

  }

  void init(llvm::Module* M) override;

  ConfigEval optimize(llvm::Module *M, bool UseDefault) override;

//  const KnobSet& getKnobs() override {
//    return Knobs;
//  }

//  const SearchSpace& getSearchSpace() override {
//  }

  bool isDone() override {
    return Done;
  }

private:
  TargetIRAnalysis getTargetIRAnalysis();
  void createPasses(const llvm::Module &M, legacy::PassManager &PM,
                                            legacy::FunctionPassManager &FPM,
                                            ParamConfig &Cfg, bool DefaultOpt);

  float computeSpeedup(TimingStats& Stats);

  void exportTree();
  void exportDotGraph(LoopTransformTree* Tree, std::string Name);

private:
  using LoopTreeList = SmallVector<LoopTransformTreePtr, 2>;
  using LoopTreeIterator = LoopTreeList::iterator ;

  clang::DiagnosticsEngine &Diags;
  const clang::HeaderSearchOptions &HSOpts;
  const clang::CodeGenOptions &CodeGenOpts;
  const clang::TargetOptions &TargetOpts;
  const clang::LangOptions &LangOpts;
  llvm::TargetMachine &TM;

  bool AllowRegression{false};

  Module *ModToOptimize;
  llvm::Optional<ConfigEval> BaseLine;

  // Trees corresponding to loop nests in the function
  LoopTreeList LoopTrees;

  // Iterator of the currently tuned loop nest
  LoopTreeIterator CurrentLoopTree;
  // Transformation decision tree for the current loop nest
  std::unique_ptr<TransformSearchTree> SearchTree;
  // Node that is currently investigated
  TransformNode* CurrentNode;
  // Best node in the current tree, corresponds to a sequence of transformations
  std::pair<TransformNode*, ConfigEval> BestNode;


  // Loop nests are tuned one after the other. This list contains the ones that have been finished.
  LoopTreeList FinalizedTrees;

  // All loop nests have been tuned.
  bool Done;

  // Counts expansion operations.
  int ExpansionCounter;

  SmallVector<int, 8> RestartCounts;

};


}
}


#endif //LLVM_TRANSFORMTREESEARCH_H

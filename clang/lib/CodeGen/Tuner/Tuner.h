//
// Created by sebastian on 24.09.19.
//

#ifndef CLANG_TUNER_H
#define CLANG_TUNER_H

#include <random>

#include "Search.h"
#include "Util.h"

namespace clang {
namespace jit {

using TunerRNE = std::mt19937_64;

struct TimingStats {
  unsigned N{0};
  double Mean{0};
  double Variance{0};
  double SD{0};

  TimingStats() = default;

  TimingStats(unsigned N, double Mean, double Variance)
      : N(N), Mean(Mean), Variance(Variance) {
    SD = std::sqrt(Variance);
  }

  bool valid() const { return N > 0 && Mean > 0 && Variance >= 0; }

  bool betterThan(const TimingStats &Other) {
    // TODO: Do t-test instead
    if (!valid())
      return false;
    if (!Other.valid())
      return true;
    return Mean < Other.Mean;
  }

  bool operator<(const TimingStats &Other) { return betterThan(Other); }

  double getTotal() { return N * Mean; }

  double getRSD() { return SD / Mean; }

  double getStdErrOfMean() { return SD / std::sqrt(N); }

  double getRelativeStdErr() { return getStdErrOfMean() / Mean; }
};

using SharedEvalStats = std::shared_ptr<TimingStats>;

#if 0
class ConfigEvalRequest {
public:
  ConfigEvalRequest() : Stats(std::make_shared<TimingStats>()){
  };

  explicit ConfigEvalRequest(KnobConfig Cfg)
      : Cfg(std::move(Cfg)), Stats(std::make_shared<TimingStats>()) {}

  KnobConfig Cfg;
  SharedEvalStats Stats;
};

struct CompareConfigEval {
  bool operator()(ConfigEvalRequest &A, ConfigEvalRequest &B) {
    if (!A.Stats || !A.Stats->Valid())
      return false;
    if (!B.Stats || !B.Stats->Valid())
      return true;
    return A.Stats->betterThan(*B.Stats);
  }
};

class Tuner {
public:
  virtual ~Tuner() {};

  virtual void reset(KnobSet Knobs) = 0;

  virtual ConfigEvalRequest generateNextConfig() = 0;
};
#endif

struct ConfigEval {
  ConfigEval() : Stats(std::make_shared<TimingStats>()) {

  }

  explicit ConfigEval(SearchSpace* Space) : Config(*Space), Stats(std::make_shared<TimingStats>()) {

  }

  explicit ConfigEval(ParamConfig Config, std::string Op = "") : Config(std::move(Config)), Stats(std::make_shared<TimingStats>()), Op(std::move(Op)) {

  }

  bool isConfigEmpty() const {
    return Config.isEmpty();
  }

  ParamConfig Config;
  SharedEvalStats Stats;
  std::string Op;

};

struct CompareConfigEval {
  bool operator()(ConfigEval &A, ConfigEval &B) {
    if (!A.Stats || !A.Stats->valid())
      return false;
    if (!B.Stats || !B.Stats->valid())
      return true;
    return A.Stats->betterThan(*B.Stats);
  }
};

class Tuner {
public:
  virtual ~Tuner() {}

  virtual ConfigEval generateNextConfig() = 0;

  virtual bool isDone() {
    return false;
  }

  virtual unsigned getNumRestarts() const {
    return 0;
  }
};

class CachingTuner: public Tuner{
public:
  CachingTuner();
  virtual ~CachingTuner() = default;

  ConfigEval generateNextConfig() override;

  llvm::Optional<ConfigEval> getEval(const ParamConfig&);

  bool isEvaluated(const ParamConfig& Config) {
    return ConfigMap.find(Config) != ConfigMap.end();
  }

  bool isDone() override {
    return Done;
  }

private:
  virtual std::pair<ParamConfig, std::string> generateNextConfigInternal() = 0;

  virtual bool attemptRestart() {
    return false;
  };

  // Stores all configuration generated by the search algo.
  llvm::SmallVector<ConfigEval, 16> Evals;
  // Maps already evaluated configurations to the evaluation data.
  llvm::DenseMap<HashableConfig, unsigned, ParamConfigMapInfo> ConfigMap;

  bool Done{false};
};

class RandomTuner : public Tuner {
public:
  explicit RandomTuner(SearchSpace& Space)
      : Space(Space), RNE(TunerRNE(util::genSeed())) {}

  ConfigEval generateNextConfig() override {
    return ConfigEval(createRandomConfig(RNE, Space));
  }

private:
  SearchSpace& Space;
  TunerRNE RNE;
};

class CachedRandomTuner : public CachingTuner {
public:
  explicit CachedRandomTuner(SearchSpace& Space)
          : Space(Space), RNE(TunerRNE(util::genSeed())) {}

  std::pair<ParamConfig, std::string> generateNextConfigInternal() {
    auto Cfg = createRandomConfig(RNE, Space);
    unsigned Tries = 0;
    while (isEvaluated(Cfg) && Tries < 10) {
      Cfg = createRandomConfig(RNE, Space);
      Tries++;
    }
    return {Cfg, "RNG"};
  }

private:
  SearchSpace& Space;
  TunerRNE RNE;
};


}
}

#endif // CLANG_TUNER_H
